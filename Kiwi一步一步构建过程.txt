Kiwi一步一步构建过程：

1，使用Qt的qmake生成vs项目：
	1，据说，如果环境变量中的qmakespec是win32-msvc2010，则生成vs2010的工程，如果是win32-msvc2008，则生成vs2008的工程。（目前没发现
	2，qmake生成vs工程的用法有两种：
		1，单工程：qmake -tp vc XXX.pro [-spec win32-msvc2008]
		
		单工程：只描述工程自己。
			XXX.pro -> 一个解决方案，一个项目
			
		例：
		vc.pro:	
			QT       += core gui
			greaterThan(QT_MAJOR_VERSION, 4): QT += widgets

			TARGET = vc
			TEMPLATE = app
			SOURCES += main.cpp\
					mainwindow.cpp
			HEADERS  += mainwindow.h
			FORMS    += mainwindow.ui

		
		2，多工程：qmake -tp vc XXX.pro -r [-spec win32-msvc2008]   //多了一个递归
		
		多工程：描述的是子工程。
			XXX.pro	-> 一个解决方案，多个项目
			- test/test.pro
			- framework/framework.pro
			- XXXX/XXXX.pro
		例：
		all.pro:
			TEMPLATE = subdirs	//指定为subdirs，必须小写！
			TARGET = 
			DEPENDPATH += .
			INCLUDEPATH += .

			SUBDIRS = vc \		//此解决方案包含了vc目录下的vc.pro
				      test  	//此解决方案包含了test目录下的test.pro

	3，使用qt的pro管理项目文件，然后生成vs工程，最后在vs IDE上开发。

	
2，使用Qt进行国际化：
	主要有三个工具：
	lupdate		通过pro文件生成ts翻译文件
	lrelease	将ts翻译文件生成pm文件
	linguist	翻译工具，用来编辑ts的翻译内容
	
	lupdate运行的时候，总出现下面的问题，但有时并不影响ts文件的生成（可能成功可能失败）。
	C:/Qt/4.7.1/mkspecs/features/default_post.prf(5):Function 'system' is not implemented
	C:/Qt/4.7.1/mkspecs/features/debug_and_release.prf(66):Function 'eval' is not implemented
	C:/Qt/4.7.1/mkspecs/features/debug_and_release.prf(69):Function 'eval' is not implemented
	C:/Qt/4.7.1/mkspecs/features/debug_and_release.prf(72):Function 'eval' is not implemented
	C:/Qt/4.7.1/mkspecs/features/debug_and_release.prf(75):Function 'eval' is not implemented
	C:/Qt/4.7.1/mkspecs/features/debug_and_release.prf(78):Function 'eval' is not implemented
	C:/Qt/4.7.1/mkspecs/features/debug_and_release.prf(80):Function 'eval' is not implemented
	C:/Qt/4.7.1/mkspecs/features/debug_and_release.prf(82):Function 'eval' is not implemented
	C:/Qt/4.7.1/mkspecs/features/debug_and_release.prf(84):Function 'eval' is not implemented
	
	由于lupdate总是假设源代码里的翻译字段的编码为某一编码，所以最好使用英文，否则产生的ts文件里的翻译字段可能是乱码。
	
	在XXX.pro文件的最后面，添加
	TRANSLATIONS += ../../../i18n/en-US/ui.ts
	TRANSLATIONS += ../../../i18n/pt-BR/ui.ts
	TRANSLATIONS += ../../../i18n/zh-CN/ui.ts
	TRANSLATIONS += ../../../i18n/zh-TW/ui.ts
	
	然后命令行运行：lupdate XXX.pro 即可生成对应的ts文件
	
3，VS的编译+链接选项：
	从VS2008复制出来的编译命令行：
	/I "c:\Qt\4.7.1\include\QtCore" /I "c:\Qt\4.7.1\include" /I "." /I "tmp" /I "c:\Qt\4.7.1\include\ActiveQt" /I "c:\Qt\4.7.1\mkspecs\win32-msvc2008" /D "UNICODE" /D "WIN32" /D "QT_LARGEFILE_SUPPORT" /D "QT_DLL" /D "QT_CORE_LIB" /D "QT_HAVE_MMX" /D "QT_HAVE_3DNOW" /D "QT_HAVE_SSE" /D "QT_HAVE_MMXEXT" /D "QT_HAVE_SSE2" /D "QT_THREAD_SUPPORT" /FD /EHsc /MDd /GS- /Zc:wchar_t- /Fo"tmp\\" /Fd".\\" /W3 /nologo /c /Zi /TP /errorReport:prompt
	
	其中： ## 参考https://msdn.microsoft.com/zh-cn/library/9wst99a9.aspx 或 https://msdn.microsoft.com/zh-cn/library/fwkeyyhe.aspx
	/I 	## 头文件目录
	/D 	## 预定义变量
	/Fo ## 指定obj的目录
	/Fd ## 指定pdb的目录
	/Zc ## 一致性（都是用Unicode
	
	从VS2008复制出来的链接命令行：
	/OUT:"..\bin\hellokiwi.exe" /NOLOGO /LIBPATH:"c:\Qt\4.7.1\lib" /MANIFEST /MANIFESTFILE:"tmp\\hellokiwi.exe.intermediate.manifest" /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /DEBUG /SUBSYSTEM:CONSOLE /DYNAMICBASE /NXCOMPAT /ERRORREPORT:PROMPT c:\Qt\4.7.1\lib\QtCored4.lib  kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib
	
	其中：
	/DEBUG	## debug版本
	/LIBPATH	##lib目录
	
	//////////////
	这些命令行是这样执行的：参考编译日志BuildLog.htm
	命令行      
	正在创建临时文件“C:\Users\ADMINI~1\AppData\Local\Temp\RSP00000C120246972.rsp”，其内容为
	[
	/I "c:\Qt\4.7.1\include\QtCore" /I "c:\Qt\4.7.1\include" /I "." /I "tmp" /I "c:\Qt\4.7.1\include\ActiveQt" /I "c:\Qt\4.7.1\mkspecs\win32-msvc2008" /D "UNICODE" /D "WIN32" /D "QT_LARGEFILE_SUPPORT" /D "QT_DLL" /D "QT_CORE_LIB" /D "QT_HAVE_MMX" /D "QT_HAVE_3DNOW" /D "QT_HAVE_SSE" /D "QT_HAVE_MMXEXT" /D "QT_HAVE_SSE2" /D "QT_THREAD_SUPPORT" /FD /EHsc /MDd /GS- /Zc:wchar_t- /Fo"tmp\\" /Fd".\\" /W3 /c /Zi /TP  -Zm200 -w34100 -w34189

	.\main.cpp
	]
	正在创建命令行“cl.exe @C:\Users\ADMINI~1\AppData\Local\Temp\RSP00000C120246972.rsp /nologo /errorReport:prompt”
	正在创建临时文件“C:\Users\ADMINI~1\AppData\Local\Temp\RSP00000D120246972.rsp”，其内容为
	[
	/OUT:"..\bin\hellokiwi.exe" /LIBPATH:"c:\Qt\4.7.1\lib" /MANIFEST /MANIFESTFILE:"tmp\\hellokiwi.exe.intermediate.manifest" /MANIFESTUAC:"level='asInvoker' uiAccess='false'" /DEBUG /SUBSYSTEM:CONSOLE /DYNAMICBASE /NXCOMPAT c:\Qt\4.7.1\lib\QtCored4.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib

	".\tmp\main.obj"
	]
	正在创建命令行“link.exe @C:\Users\ADMINI~1\AppData\Local\Temp\RSP00000D120246972.rsp /NOLOGO /ERRORREPORT:PROMPT”
	正在创建临时文件“C:\Users\ADMINI~1\AppData\Local\Temp\RSP00000E120246972.rsp”，其内容为
	[
	/outputresource:"..\bin\hellokiwi.exe;#1" /manifest

	.\tmp\hellokiwi.exe.intermediate.manifest
	]
	正在创建命令行“mt.exe @C:\Users\ADMINI~1\AppData\Local\Temp\RSP00000E120246972.rsp /nologo”
	正在创建临时文件“C:\Users\ADMINI~1\AppData\Local\Temp\BAT00000F120246972.bat”，其内容为
	[
	@echo 清单资源上次更新时间为 %TIME%，更新位置为 %DATE% > .\tmp\mt.dep
	]
	正在创建命令行“C:\Users\ADMINI~1\AppData\Local\Temp\BAT00000F120246972.bat”

	可见：执行过程是cl.exe -> link.exe -> mt.exe -> *.bat
	/////////////
	
	msbuild.exe/cl.exe/link.exe/nmake.exe/devenv.exe/ml.exe/rc.exe/mt.exe/lib.exe
	//这个帖子总结得不错，可参考http://blog.csdn.net/xiexievv/article/details/45775005
	
	msbuild.exe：比较强大，基本是命令行下的VS，可以在命令行下执行VS相关的操作，比如clean、build、rebuild、配置项目属性等。	
	参考https://msdn.microsoft.com/zh-cn/library/dd293607.aspx和github：https://github.com/Microsoft/msbuild
	1，配置VS项目；## /p:config=value 通过使用属性命令行选项 (/p)，您可以在项目生成文件中重写属性。
		msbuild myproject.vcxproj /p:configuration=debug /p:platform=win32 ##重写myproject.vcxproj项目文件里面的configuration和platform属性
	2，生成VS项目：## /t:cmd
		msbuild myproject.vcxproj /p:configuration=debug ##编译构建myproject.vcxproj的DEBUG版本。
		msbuild myproject.vcxproj /t:rebuild
		myproject ##生成后，调用程序
	缺点：依赖于.Net Framework 4.5.1以上，安装庞大；且只支持vcxproj而不支持vs2008的vcproj，后者需要转换。
		
	devenv.exe：VS的界面运行程序devenv.exe，也可以在命令行设置参数运行devenv.com。后者可用来设置集成开发环境 (IDE) 的各个选项，以及从命令行生成、调试和部署项目。【对于与编译构建相关的任务，现在推荐使用 MSBuild，而非 devenv】
		一些例子：##更多参考https://msdn.microsoft.com/zh-cn/library/xee0c8y7.aspx 或直接devenv /?
		devenv myproj.csproj /build /out log.txt ##生成时指定一个文件接收错误。
		devenv myproj.csproj /clean ##清理项目
		devenv myproj.csproj /build ##编译构建
		devenv myproj.csproj /build Debug ##编译构建Debug版本

	cl.exe：VS的编译工具，无论是使用IDE，还是命令行MSBuild，最终编译*.cpp文件的还是cl.exe【将.c，.cpp，.cxx编译成obj文件】
	link.exe：VS的链接工具，同上，无论是使用IDE，还是命令行MSBuild，最终都是调用link.exe来链接.obj和.lib等文件来生成目标。【将obj、lib、res链接成dll或exe等可执行文件】
	nmake.exe：Windows下的make工具，解析makefile来自动编译构建项目。仍旧需要使用cl.exe编译器（或其它编译器）和link.exe链接器(或其它链接器)。【执行makefile构建dll或exe等目标】
	CMake是一个跨平台的安装(编译)工具,可以用简单的语句来描述所有平台的安装(编译过程)。他能够输出各种各样的makefile或者project文件,能测试编译器所支持的C++特性,类似UNIX下的automake。
	ml.exe：汇编的编译工具，MASM编译工具。64位为ml64.exe。masm and link。【将.asm编译生成.obj文件，貌似可以直接生成exe可执行文件】
		
	rc.exe：Windows资源编译器工具，将例如游标、图标、位图、对话框和字体的资源编译为一个资源 (.res) 文件。【将.rc资源文本转变成.res二进制文件】
	lib.exe：具体不太清楚，貌似是用于提取dll的def文件。参考https://msdn.microsoft.com/zh-cn/library/0xb6w1f8.aspx
	mt.exe：清单文件生成工具。项目>属性>链接器>清单文件>生成清单>是/否。生成一个*.manifest清单文件和mt.dep生成清单的日期文件。

	【清单：https://msdn.microsoft.com/zh-cn/library/ms235605.aspx
	在命令行中使用 nmake 或类似工具生成 C/C++ 应用程序时，将在链接器处理完所有对象文件并生成最终二进制文件后生成清单。链接器收集存储在对象文件中的程序集信息，并将此信息合并到最终清单文件中。默认情况下，链接器将生成一个名为<binary_name>.<extension>.manifest 的文件，用于描述最终二进制文件。链接器不会将清单文件嵌入此二进制文件中，只能将清单生成为外部文件。有几种方法可将清单嵌入最终二进制文件中，如使用清单工具 (mt.exe) 或将清单编译为资源文件。切记：将清单嵌入最终二进制文件中时，必须遵守特定的规则，这样才能启用诸如增量链接、签名、编辑并继续等功能。 如何：将清单嵌入到 C/C++ 应用程序 中讨论了在命令行生成清单时使用的这些功能及其他选项。】

	VS新版本(VS2015)项目后缀：参考：https://msdn.microsoft.com/zh-cn/library/ee862524.aspx
	.vcproj 现在为 .vcxproj Visual Studio 会自动将在 Visual C++ 早期版本中创建的项目文件转换为当前系统所用的格式。有关如何手动升级项目的更多信息，请参见 /Upgrade (devenv.exe)。
	.vsprops 现在为 .props 在早期版本中，项目属性表是具有 .vsprops 文件扩展名的、基于 XML 的文件。使用项目属性表可以为生成工具（如编译器或链接器）指定开关并创建用户定义的宏。
在当前2015版本中，项目属性表的文件扩展名为 .props。
	.vcxproj.user 文件
	用户文件 (.vcxproj.user) 存储特定于用户的属性，例如调试和部署设置。vcxproj.user 文件应用于特定用户的所有项目。
	
4，QT pro文件详解
	参考http://doc.qt.io/qt-4.8/qmake-variable-reference.html

	示例：
	message($$_PRO_FILE_) ##http://doc.qt.io/qt-5/qmake-variable-reference.html

	QT_VERSION = 4.7.1	##指定QT版本

	QT -= gui ## Only the core module is used.By default, QT contains both core and gui

	TEMPLATE = app
	TARGET = hellokiwi
	CONFIG += console
	DEFINES += 

	RCC_DIR = ./tmp		## RCC文件存放目录
	MOC_DIR = ./tmp		## MOC文件存放目录
	OBJECTS_DIR = ./tmp ## 临时OBJ文件存放目录	 - 生成VS项目文件时，也会将此目录配置为中间文件存放目录

	QMAKE_CLEAN += ./tmp ## clean时清除的目录

	DESTDIR = ../bin
	DLLDESTDIR = ../bin
	INCLUDEPATH = ./ ./tmp	## 临时目录里有对应的头文件，因此要包含
	win32:INCLUDEPATH += ./
	win32:LIBS += 

	RESOURCES +=

	OBJECTS += ## Specify the extension of each source file is replaced by .o (Unix) or .obj (Win32). You can add objects to the list.
	SOURCES += main.cpp

	##总体思路是，由pro管理Linux和Windows下的两个版本。Linux下直接使用pro文件，Windows下通过qmake将pro文件转换为VS的项目文件，并使用VS进行开发（转换过程实现配置的转换，以便转换后不需再配置VS）。
	
5，可重入与线程安全与类型安全：
	可重入的（Reentrant）：如果多个线程可以在同一时刻调用一个类的所有函数，并且保证每一次函数调用都引用一个唯一的数据，就称这个类是可重入的（Reentrant means that all the functions in the referenced class can be called simultaneously by multiple threads, provided that each invocation of the functions reference unique data.）。大多数C++类都是可重入的。类似的，一个函数被称为可重入的，如果该函数允许多个线程在同一时刻调用，而每一次的调用都只能使用其独有的数据。全局变量就不是函数独有的数据，而是共享的。换句话说，这意味着类或者函数的使用者必须使用某种额外的机制（比如锁）来控制对对象的实例或共享数据的序列化访问。
	
	线程安全（Thread-safe）：如果多个线程可以在同一时刻调用一个类的所有函数，即使每一次函数调用都引用一个共享的数据，就说这个类是线程安全的（Threadsafe means that all the functions in the referenced class can be called simultaneously by multiple threads even when each invocation references shared data.）。如果多个线程可以在同一时刻访问函数的共享数据，就称这个函数是线程安全的。	
	
	类型安全（Type-safe）：
	类型安全是指我们使用一个类的指针在调用类的函数或传递类的对象时，该指针“确实”是指向我们所规定的类的对象。也可以说是指针的指向 类型的转换 精度的丢失 异常的保护等。也可以这样理解：类型安全的模块，如果传递了非识别的类型，将能使编译器编译错误，让人知道类型错误。
	例如：
	class A;
	A *p=new A;
	p->func();   //类型不安全，我们不能保证指针p 
				//“确实”指向类A的一个对象，因为前面的new可能不成功。
	或者
	Pointer A = new B();	//如果类型安全，这个语句将会导致编译错误。因为B指针不能赋予A指针。
	像C的union，结构体等可以任意赋值，这就是类型不安全。
	


7，本来打算使用QT的QCoreApplication来做一个命令行终端，但是QT的QCoreApplication并不支持键盘事件，因此即使监听它的事件，也无法获取键盘按键信息。
	所以，放弃了使用QT的终端程序，而使用了getch()方式实现，头文件为conio.h。
	conio.h是Windows终端的头文件，在Linux下也有一个对应的兼容性版本，理论上可以跨平台。
	
	但是，conio.h虽然可以捕获键盘事件，但是在下一行删除到尽头的时候，退格不会自动跳到上一行而导致修改输入变得不可控。
	
	为什么需要conio.h呢？因为需要在command-line模式下监听键盘事件，以便在Tab的时候实现自动补全。
	其实，这里完全可以自己实现一个命令行窗口，窗口的标题、样式、布局都是自己实现的，这样命令行的输入监控就变成了对一个控件的监控。这种自己实现命令行窗口的做法，可以轻易实现在用户输入的时候监控键盘行为。只是，这样的程序是以窗口形式存在的，鼠标右键菜单等都需要自己实现，其次最根本的是它以GUI形式存在，如果在Linux的文本模式下将无法运行。
	
	然而，开发这个工具的出发点是，它以文本模式存在，能够在Windows命令行或者Linux的shell下生存并临时接管它们的一些键盘事件（这样说来，可以使用hook，像Windows下hook到命令行窗口的事件）。

	http://www.codeproject.com/Articles/2357/Console-Event-Handling
	
8，	
	http://www.codeproject.com/Articles/6614/Generic-Observer-Pattern-and-Events-in-C
	//所有的mt_policy其实是库定义的三种锁策略而已[单线程无锁、多线程共享全局锁、多线程局部锁]

TODO sigslot.h与QT的整合：sigslot.h要先于QT库引入，否则会编译失败。
TODO QObject基类在多重继承时的位置：放在首位，因为moc.exe是根据首位对象来生成成员metaObject，否则编译失败。
TODO VS2008没有自动执行moc.exe的问题，要讲moc_XXX.cpp加入到源文件才能通过编译。http://vperi.com/2012/04/23/automatic-mocing-in-visual-studio/

9，命令行的历史记录实现：
	历史记录需要：上一条、下一条、当前位置、历史记录位置
	   1 2 3 4 5 
	   * 
		 * * * *   len = 5;
	   |           index = 0 last = 4 next = 1
		 |         index = 1 last = 0 next = 2
		   |
			 |
			   |   index = 4 last = 3 next = 0